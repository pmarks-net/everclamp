import os
import re
import pathlib
import stl  # XXX offer to install?
import hashlib
import tkinter
import tkinter.filedialog
import traceback
import sys
import argparse

# Hopefully this works on all OSes:
home_dir = os.path.expanduser('~')
library_dirs = [os.path.join(home_dir, 'Documents', 'OpenSCAD', 'libraries'),
                os.path.join(home_dir, '.local', 'share', 'OpenSCAD', 'libraries')]


class BundleError(Exception):
    pass



def bundle_scad(*args):
    included_files = set()
    used_files = set()
    out_scad = ''

    for arg in args:
        out_scad += parse_file('.', arg, included_files, used_files)

    if not used_files:
        print("renamer_hack() not needed")
    else:
        BUILTINS = 'BOSL2/builtins.scad'
        split_path = lambda p: pathlib.Path(p).parts
        try:
            use, = used_files
            if split_path(use)[-2:] != split_path(BUILTINS):
                raise ValueError
        except ValueError:
            raise BundleError(f"Don't know how to process used_files={used_files}")
        else:
            print(f"applying renamer_hack() for {BUILTINS}")
            out_scad = renamer_hack(out_scad) + parse_file('.', BUILTINS, set(), set())
    
    return clean_whitespace(out_scad)



def safe_write(path, contents):
    checksum_footer = "// bundle_scad checksum="
    basename = os.path.basename(path)

    print(f"writing {path}")

    if checksum_footer in contents:
        raise BundleError(f"Skipped {basename}: already a bundle")

    checksum = lambda x: hashlib.sha512(x.encode('utf-8')).hexdigest()[:32]

    if os.path.exists(path):
        with open(path, "r") as f:
            existing_contents = f.read()
        footer_index = existing_contents.find(checksum_footer)
        if footer_index == -1:
            raise BundleError(
                f"Refused to overwrite {basename} because it was not generated by this utility. "
                "Consider deleting the file.")
        else:
            expected_checksum = existing_contents[footer_index+len(checksum_footer):].strip()
            content_to_check = existing_contents[:footer_index]
            actual_checksum = checksum(content_to_check)
            if expected_checksum != actual_checksum:
                raise BundleError(
                    f"Refused to overwrite {basename} because it has been modified. "
                    "Consider deleting the file.")
            print(f"overwriting {basename}")

    # Compute checksum for new contents and write to file
    full_contents = contents + checksum_footer + checksum(contents) + "\n"
    with open(path, "w") as f:
        f.write(full_contents)

    print("done")


def clean_whitespace(code_str):
    code_str = '\n'.join([line.rstrip() for line in code_str.split('\n')])
    code_str = re.sub(r'\n{3,}', '\n\n', code_str)
    return code_str


def read_one(dirs, filename):
    for d in dirs:
        try:
            full_path = os.path.normpath(os.path.join(d, filename))
            f = open(full_path, 'r')
            return full_path, f.read()
        except FileNotFoundError:
            continue  # If file is not found, proceed to the next directory

    # If no file has been successfully opened after checking all directories
    raise FileNotFoundError(f'{filename} not found in dirs={dirs}')


# Even indices contain code, odd indices contain comments or strings.
def split_into_code_and_noncode(contents):
    pattern = r'("(?:[^"\\]|\\.)*"|//.*?$|/[*].*?[*]/)'
    try:
        parts = re.split(pattern, contents, flags=re.DOTALL | re.MULTILINE)
    except:
        print(f"pattern={pattern} contents={contents}")
        raise
    return parts


def parse_file(directory, filename, included_files, used_files, nesting_level=0):
    output = ''
    full_path, contents = read_one((directory, *library_dirs), filename)

    # Check if file has already been included
    if full_path in included_files:
        return ''
    else:
        included_files.add(full_path)

    print(f"reading {full_path}")
    directory = os.path.dirname(full_path)

    strip_comments = (nesting_level > 0)

    for i, part in enumerate(split_into_code_and_noncode(contents)):
        #print(f"i={i} part={part}")
        if i % 2 == 0:  # code
            for line in part.splitlines(True):
                match = re.match(r'^(include|use)\s*<([^>]*)>', line)
                if not match:
                    output += line
                    continue
                cmd, f = match.groups()
                
                if cmd == 'use':
                    # Not sure how to bundle 'use', so just resolve the path.
                    use_path, _ = read_one((directory, *library_dirs), f)
                    used_files.add(use_path)
                    continue

                if nesting_level == 0:
                    match = re.match(r'^([a-zA-Z0-9_]+[.]stl)[.]scad$', f)
                    if match:
                        stl_file, = match.groups()
                        stl_to_scad(os.path.join(directory, stl_file))
                
                # Recursively parse the included file
                output += parse_file(
                    os.path.dirname(full_path),
                    f,
                    included_files,
                    used_files,
                    nesting_level + 1)
        elif part.startswith('"'):  # string literal
            output += part
        elif not strip_comments:  # comment
            output += part

    return output


def stl_to_scad(stl_file, object_name='stl_blob'):
    scad_file = f'{stl_file}.scad'
    print(f"converting {stl_file} -> {scad_file}, module {object_name}")
    
    with open(stl_file, 'rb') as f:
        content = f.read()

    vertices = []
    triangles = []
    vertex_index = 0
    modules = ''
    calls = ''

    try:
        content_ascii = content.decode('ascii')
    except UnicodeDecodeError:
        content_ascii = None

    if content_ascii:
        for obj in content_ascii.split('endsolid'):
            matches = re.findall(r'loop[\s\S]*?endloop', obj, re.M | re.I)
            for m in matches:
                v = re.findall(r'vertex\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s*'
                               'vertex\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s*'
                               'vertex\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s+(-?\d+\.?\d*[Ee]?\-?\+?\d*\.?\d*)\s*',
                               m, re.M | re.I)
                for vertex in v:
                    v1 = '[{}]'.format(','.join(vertex[0:3]))
                    v2 = '[{}]'.format(','.join(vertex[3:6]))
                    v3 = '[{}]'.format(','.join(vertex[6:9]))
                    triangles.append(f'[{vertex_index},{vertex_index + 1},{vertex_index + 2}]')
                    vertex_index += 3
                    vertices.extend([v1, v2, v3])
    else:
        m = stl.mesh.Mesh.from_file(stl_file)
        for v1, v2, v3 in m.vectors:
            v1 = '[{}]'.format(','.join([str(v) % v for v in v1]))
            v2 = '[{}]'.format(','.join([str(v) % v for v in v2]))
            v3 = '[{}]'.format(','.join([str(v) % v for v in v3]))
            triangles.append(f'[{vertex_index},{vertex_index + 1},{vertex_index + 2}]')
            vertex_index += 3
            vertices.extend([v1, v2, v3])
            
    poly = 'polyhedron(\npoints=[{}],\nfaces=[{}]);'.format(','.join(vertices), ','.join(triangles))
    modules += f'module {object_name}(){{\n{poly}\n}}\n'

    # Write the result to the OpenSCAD file
    safe_write(scad_file, modules)

# It seems impossible to emulate this with a preprocessor:
#
#   use <BOSL2/builtins.scad>
#
# BOSL2 redefines builtin modules like cylinder(), but this depends
# on the behavior of "use", so instead we have to mess with the SCAD
# code so that cylinder() calls renamer_hack_cylinder() instead.
#
# This hack is necessary if you see errors like this:
#
#   ERROR: Recursion detected calling function
#
# In that case, you have to run renamer_hack() on everything except builtins.scad.
# The everclamp thread stuff doesn't use builtins, so this function is unused.
def renamer_hack(scad_code):
    # You might need to mess with this list.
    pattern = r'\b(square|circle|cube|cylinder|sphere|text)(?=\s*\()'
    
    # Function to add prefix to matched modules
    def add_prefix_to_module(match):
        return "renamer_hack_" + match.group(1)

    parts = split_into_code_and_noncode(scad_code)
    
    for i, part in enumerate(parts):
        # Only replace within normal code (i.e., even indices)
        if i % 2 == 0:
             parts[i] = re.sub(pattern, add_prefix_to_module, part)
    
    return ''.join(parts)


def print_files(msg, files):
    print(msg)
    for f in files:
        print(f"  {f}")
    if not files:
        print("  (none)")
        


def main(file_paths):
    if not file_paths:
        print("No filenames on command line; using file picker...")
        file_paths = tkinter.filedialog.askopenfilenames(
            filetypes=[('STL or SCAD file', '*.stl *.scad')],
            title="Select file(s) to bundle")        

    good_files = []
    bad_files = []

    for path in file_paths:
        try:
            if path.endswith(".stl"):
                stl_to_scad(path)
            elif path.endswith(".scad"):
                out_path = path.removesuffix(".scad") + ".bundle.scad"
                safe_write(out_path, bundle_scad(path))
            else:
                raise BundleError(f"unknown filetype: {path}")
            good_files.append(path)
        except BundleError:
            traceback.print_exc()
            bad_files.append(path)

    print_files("\nSuccessful inputs:", good_files)
    print_files("\nFailed inputs:", bad_files)
    

if __name__ == '__main__':
    file_paths = sys.argv[1:]
    try:
        main(file_paths)
    except:
        traceback.print_exc()
    if not file_paths:
        input("\nPress Enter or Ctrl-C to exit...")
